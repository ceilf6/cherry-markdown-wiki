## 简介
| 包名 | 作用 |
| ------ | ------ |
|`cherry-markdown.js`<br>`cherry-markdown.min.js`| 完整包，较大，包含cherry所有功能（工具栏、左侧编辑器、右侧预览器）| 
|`cherry-markdown.core.js`| 核心包，相比完整包，只少了mermaid功能，包大小小了50%以上<br>（当然也可以在引入核心包后再[传入mermaid](https://github.com/Tencent/cherry-markdown#%EF%B8%8F-about-mermaid)，从而实现对mermaid的支持）|
|`cherry-markdown.engine.core.js`| 解析引擎包，可以理解为只提供了[将md解析成html的api](https://github.com/Tencent/cherry-markdown#node) |
|`cherry-markdown.css`|样式文件，包括了编辑区、工具栏、预览区等样式|
|`cherry-markdown.markdown.css`|预览区内的样式文件，会对 `class="cherry-markdown"`元素里的html应用样式|


前缀 | 后缀 | 模块 | 语言版本 | UI | 核心引擎 | 大体积依赖(mermaid等) | 建议使用环境 | 免构建用于生产
-- | -- | -- | -- | -- | -- | -- | -- | --
cherry-markdown | .js | umd | es5 | ✅ | ✅ | ✅ | Web | ❌
cherry-markdown | .esm.js | esm | es2015 | ✅ | ✅ | ✅ | Web | ❌
cherry-markdown | .min.js | umd | es5 | ✅ | ✅ | ✅ | Web | ✅
cherry-markdown.core | .js | umd | es5 | ✅ | ✅ | ❌ | Web | ❌
cherry-markdown.core | .common.js | cjs | es5 | ✅ | ✅ | ❌ | Node | ❌
cherry-markdown.engine.core | .js | umd | es5 | ❌ | ✅ | ❌ | Web | ❌
cherry-markdown.engine.core | .esm.js | esm | es2015 | ❌ | ✅ | ❌ | Web | ❌
cherry-markdown.engine.core | .common.js | cjs | es5 | ❌ | ✅ | ❌ | Node | ❌


## 注意
有用户反馈只引入`cherry-markdown.engine.core.js`时，[自定义语法失效](https://github.com/Tencent/cherry-markdown/issues/905)，目前该问题还在排期修复中，如有使用自定义语法诉求时，还请先用 `cherry.engine`哈

## 引入mermaid
`cherry-markdown.js`里包含了mermaid（V9.4.3），如果业务方有自己版本的mermaid，则可先使用`cherry-markdown.core.js`包，然后通过以下三种方式引入自己版本的mermaid。

### 在线demo
https://tencent.github.io/cherry-markdown/examples/mermaid.html

### 方式一：定义`window.mermaid`属性
```
<...>
  <!-- 默认注入mermaid到window -->
  <script src="https://cdn.com/mermaid/dist/mermaid.min.js"></script>
  <script>
    import mermaidPlugin from 'cherry/dist/addons/cherry-code-block-mermaid-plugin';
    import cherry from 'cherry';
    cherry.usePlugin(mermaidPlugin, {
      mermaid: window.mermaid,
      mermaidAPI: window.mermaid, // 如果mermaid的版本号>10.x，则重置mermaidAPI为mermaid
    }); // 默认从 window.mermaid 获取
    new cherry();
  </script>
</...>
```


### 方式二：同步引入mermaid并传值给cherry
```
import mermaidPlugin from 'cherry/dist/addons/cherry-code-block-mermaid-plugin';
import cherry from 'cherry';
import mermaid from 'mermaid';
cherry.usePlugin(mermaidPlugin, { mermaid });
new cherry();
```


### 方式三：异步引入mermaid并传值给cherry
```
import mermaidPlugin from 'cherry/dist/addons/cherry-code-block-mermaid-plugin';
import cherry from 'cherry';

(async () => {
  const mermaid = await import('mermaid');
  cherry.usePlugin(mermaidPlugin, { mermaid });
  new cherry();
})()
```

### 注意
从 mermaid v10.0.0 开始，渲染逻辑由之前的同步渲染改成了异步渲染，`afterChange` 或者 `afterInit` 事件后，mermaid 代码块会先渲染为占位符，然后异步渲染并替换。

如需在异步渲染结束后获取内容，可以按以下方式。
``` javascript
const cherryInstance = new Cherry({
  id: 'markdown-container',
  value: '
    ```mermaid
    graph LR
        A[公司] -->| 下 班 | B(菜市场)
        B --> C{看见<br>卖西瓜的}
        C -->|Yes| D[买一个包子]
        C -->|No| E[买一斤包子]
    ```
  ',
  callback: {
    afterAsyncRender: (md, html) => {
      // md 是 markdown 源码，html 是渲染结果
    }
  }
});
```

## 引入echarts
```
import cherry from 'cherry';
import echarts from 'echarts';
import echartsEngine from 'cherry/dist/addons/advance/cherry-table-echarts-plugin';

cherry.usePlugin(echartsEngine , { echarts });
new cherry();
```